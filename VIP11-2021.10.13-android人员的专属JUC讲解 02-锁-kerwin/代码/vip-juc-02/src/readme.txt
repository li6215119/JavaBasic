

1.++ 操作，不是单纯的原子操作，里面从指令层面来说，他是4个指令完成一次加完之后的复制
    提数据，在计算，在复制

synchronized其实是提供一种去对线程进行阻断的一个条件依据


对象头中实际上采用的是64位数据作为承载
如果是数组则是96位，多一个32位的长度
markword 32位数据，没有固定的数据格式

根据状态对于里面的数据进行变更
状态



1.我们现在是纤细monitor占用空间大，而且在某些场景下没有比较

    场景：
        1.单个线程在运行---》仅仅只要进行标记一下--->直接标记在我们markword上面
        2.两个线程在运行---》我的需求，要不就是1用，要不就是2用，我也不要monitor，但是需要有数据的记录
            这个时候我们要想个地方来存两个线程的数据，所以我找了个地方，就是栈帧里面，好处是什么？
        3.多个线程在运行（需要monitor的支持）

        所谓的锁膨胀，就是在线程慢慢开辟的过程中，他的处理方案的变更


        底层C的运行过程


        interpreterRuntime--->synchronize--->加偏向锁--->锁升级--》上面三套方案


    CAS，一套方案--》做什么事情？---》同步数据---》同步主内存和工作内存的数据

    实际上是在逻辑层面运用算法和判定去规避数据异常的方案，这个方案比加锁强吗？


    JUC当中  AQS-->工具包--》API----->是基于CAS理论去处理同步问题的实现ABA


    1.认识JAVA锁
    2.JAVA锁不是处理互斥的唯一方案
    3.CAS理论的应用也可以解决互斥