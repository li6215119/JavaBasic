android人员的专属JUC讲解
		03-无锁并发与有锁并发
技术点：
    1.CAS效率分析与原子变量
    2.原子引用下的ABA问题
    3.原子更新器与累加器
    4.LongAddr原理
    5.unsafe实现原子数组



    synchronize JVM提供的锁， 他影响的范围是跟CPU有关，
    会造成阻塞现象，阻塞现场会造成线程上下文的切换
    线程间切换，实际上是作了很多事情的，
    因为时间片的关系，
    单核给一个线程用，
    时间片--》划分---》宏观上形成并行---》执行速度的问题--》看起来没有感觉
    线程占用CPU的过程，就是切换


    比如：
        1.当前线程需要执行的指令，以及他的程序计数器，内部的一些数据是需要保存的

    CAS是一种策略，这个策略是为了保证 主内存中的数据在被多个线程赋值的使用，是一个准确的

    为了达到这个目的，他采取的方案是
        把旧值保留，拿就只与主内存比对，如果不对，重读在加载


    CAS 必须和volatile关键字配合使用，原因： 在保证线程安全性的前提下，要保证可见性
    重读一样耗性能，那么synchronize切换也耗性能


    运用CAS的理论能完成锁功能一样的效果

    加锁了吗？没加， 一直在做值检测， 过了就放掉

    synchronize--》休息，阻塞掉，直接放掉CPU资源，下一次过来用的使用，需要恢复寄存器数据


    CAS这种无锁模式去进行安全处理会比有锁块吗？
        1.你的线程数量不多，最好和CPU核数对应，他是最优的方案
        2.如果我上来100000线程CAS效率绝对慢

        android的使用环境


    对于单个属性进行处理，提供Atomic工具
        AtomicInteger  原子整数
    所有的原子操作实际上是在顶层进行了一个CAS的循环比较，只有达成目的，我就退出

    祖师爷在考虑并发的时候，考虑了我们在实际并发中会出现的问题场景，其中绝大部分是对于某个属性的数据安全的处理
    所以他帮我搞了一组Atomic实现，利用的是CAS理论，不加锁的方案进行处理，在线程数不多的情况下，
    核数合适的情况下，当前方案的速度由于synchronize

    //基本数据数据类型
    //引用类型 AtomicReference 处理的是引用类型的值-->地址
    //ABA理论：



    //数组
    //对象


    int i  = 0;

    Thread1 --> i ++
    Thread2 --> i ++

    实际业务操作过程当中，对于android而言，最容易出现数据问题的是标志的累加


    在进行这种数组元素使用到工作内存中时，会出现伪共享的问题



    并发：
        目的：
            1.面试-》JAVA
            2.实用-》
        1.JMM内存模型-->做到了解线程并发的本质
        2.有锁并发-悲观锁（synchronize锁体系）
        3.无锁并发-乐观锁（CAS无锁并发）
        4.阻塞队列AQS内部机制
        5.线程池

















